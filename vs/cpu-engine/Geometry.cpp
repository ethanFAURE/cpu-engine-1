#include "stdafx.h"

VERTEX::VERTEX()
{
	Identity();
}

void VERTEX::Identity()
{
	pos = { 0.0f, 0.0f, 0.0f };
	color = { 1.0f, 1.0f, 1.0f };
	normal = { 0.0f, 0.0f, 1.0f };
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

TRIANGLE::TRIANGLE()
{
	Identity();
}

void TRIANGLE::Identity()
{
	v[0].Identity();
	v[1].Identity();
	v[2].Identity();
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

RECTANGLE::RECTANGLE()
{
	Zero();
}

void RECTANGLE::Zero()
{
	min = { 0.0f, 0.0f };
	max = { 0.0f, 0.0f };
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

AABB::AABB()
{
	Zero();
}

AABB& AABB::operator=(const OBB& obb)
{
	min = {  FLT_MAX,  FLT_MAX,  FLT_MAX };
	max = { -FLT_MAX, -FLT_MAX, -FLT_MAX };

	for ( int i=0 ; i<8 ; ++i )
	{
		const auto& p = obb.pts[i];

		if ( p.x<min.x )
			min.x = p.x;
		if ( p.y<min.y )
			min.y = p.y;
		if ( p.z<min.z )
			min.z = p.z;

		if ( p.x>max.x )
			max.x = p.x;
		if ( p.y>max.y )
			max.y = p.y;
		if ( p.z>max.z )
			max.z = p.z;
	}
	return *this;
}

void AABB::Zero()
{
	min = { 0.0f, 0.0f, 0.0f };
	max = { 0.0f, 0.0f, 0.0f };
}

bool XM_CALLCONV AABB::ToScreen(RECTANGLE& out, DirectX::FXMMATRIX wvp, float renderWidth, float renderHeight)
{
	const float renderX = 0.0f;
	const float renderY = 0.0f;
	float minX =  FLT_MAX, minY =  FLT_MAX;
	float maxX = -FLT_MAX, maxY = -FLT_MAX;

	const float xmin = min.x;
	const float ymin = min.y;
	const float zmin = min.z;
	const float xmax = max.x;
	const float ymax = max.y;
	const float zmax = max.z;

	const DirectX::XMVECTOR pts[8] =
	{
		DirectX::XMVectorSet(xmin, ymin, zmin, 1.0f),
		DirectX::XMVectorSet(xmax, ymin, zmin, 1.0f),
		DirectX::XMVectorSet(xmax, ymax, zmin, 1.0f),
		DirectX::XMVectorSet(xmin, ymax, zmin, 1.0f),
		DirectX::XMVectorSet(xmin, ymin, zmax, 1.0f),
		DirectX::XMVectorSet(xmax, ymin, zmax, 1.0f),
		DirectX::XMVectorSet(xmax, ymax, zmax, 1.0f),
		DirectX::XMVectorSet(xmin, ymax, zmax, 1.0f)
	};

	for ( int i=0 ; i<8 ; ++i )
	{
		DirectX::XMVECTOR clip = XMVector4Transform(pts[i], wvp);

		float w = DirectX::XMVectorGetW(clip);
		if ( w<=0.00001f )
			continue; // derrière caméra

		float invW = 1.0f / w;
		float ndcX = DirectX::XMVectorGetX(clip) * invW;
		float ndcY = DirectX::XMVectorGetY(clip) * invW;

		float sx = renderX + (ndcX * 0.5f + 0.5f) * renderWidth;
		float sy = renderY + (-ndcY * 0.5f + 0.5f) * renderHeight;

		minX = std::min(minX, sx);
		minY = std::min(minY, sy);
		maxX = std::max(maxX, sx);
		maxY = std::max(maxY, sy);
	}

	// Outside
	if ( minX>maxX || minY>maxY )
		return false;

	minX = Engine::Clamp(minX, renderX, renderX+renderWidth);
	maxX = Engine::Clamp(maxX, renderX, renderX+renderWidth);
	minY = Engine::Clamp(minY, renderY, renderY+renderHeight);
	maxY = Engine::Clamp(maxY, renderY, renderY+renderHeight);
	out.min = { minX, minY };
	out.max = { maxX, maxY };
	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

OBB::OBB()
{
	Zero();
}

OBB& OBB::operator=(const AABB& aabb)
{
	// Bas (zmin) puis Haut (zmax), en tournant sur x/y
	const float xmin = aabb.min.x, ymin = aabb.min.y, zmin = aabb.min.z;
	const float xmax = aabb.max.x, ymax = aabb.max.y, zmax = aabb.max.z;
	pts[0] = { xmin, ymin, zmin };
	pts[1] = { xmax, ymin, zmin };
	pts[2] = { xmax, ymax, zmin };
	pts[3] = { xmin, ymax, zmin };
	pts[4] = { xmin, ymin, zmax };
	pts[5] = { xmax, ymin, zmax };
	pts[6] = { xmax, ymax, zmax };
	pts[7] = { xmin, ymax, zmax };
	return *this;
}

void OBB::Zero()
{
	for ( int i=0 ; i<8 ; i++ )
		pts[i] = { 0.0f, 0.0f, 0.0f };
}

void XM_CALLCONV OBB::Transform(DirectX::FXMMATRIX m)
{
	for ( int i=0 ; i<8 ; ++i )
	{
		DirectX::XMVECTOR p = XMLoadFloat3(&pts[i]);
		p = XMVector3TransformCoord(p, m);
		XMStoreFloat3(&pts[i], p);
	}
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

RAY::RAY()
{
	Identity();
}

void RAY::Identity()
{
	pos = { 0.0f, 0.0f, 0.0f };
	dir = { 0.0f, 0.0f, 1.0f };
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

MESH::MESH()
{
	Clear();
}

void MESH::Clear()
{
	triangles.clear();
	aabb.Zero();
}

void MESH::AddTriangle(DirectX::XMFLOAT3& a, DirectX::XMFLOAT3& b, DirectX::XMFLOAT3& c, DirectX::XMFLOAT3& color)
{
	TRIANGLE t;
	t.v[0].pos = a;
	t.v[0].color = color;
	t.v[1].pos = b;
	t.v[1].color = color;
	t.v[2].pos = c;
	t.v[2].color = color;
	triangles.push_back(t);
}

void MESH::AddFace(DirectX::XMFLOAT3& a, DirectX::XMFLOAT3& b, DirectX::XMFLOAT3& c, DirectX::XMFLOAT3& d, DirectX::XMFLOAT3& color)
{
	AddTriangle(a, c, b, color);
	AddTriangle(a, d, c, color);
}

void MESH::Optimize()
{
	CalculateNormals();
	CalculateBox();
}

void MESH::CalculateNormals()
{
	std::map<DirectX::XMFLOAT3, DirectX::XMVECTOR, VEC3_CMP> normalAccumulator;
	for ( TRIANGLE& t : triangles )
	{
		DirectX::XMVECTOR p0 = DirectX::XMLoadFloat3(&t.v[0].pos);
		DirectX::XMVECTOR p1 = DirectX::XMLoadFloat3(&t.v[1].pos);
		DirectX::XMVECTOR p2 = DirectX::XMLoadFloat3(&t.v[2].pos);

		DirectX::XMVECTOR edge1 = DirectX::XMVectorSubtract(p1, p0);
		DirectX::XMVECTOR edge2 = DirectX::XMVectorSubtract(p2, p0);
		DirectX::XMVECTOR faceNormal = DirectX::XMVector3Cross(edge1, edge2);
		
		if ( normalAccumulator.count(t.v[0].pos)==0 )
			normalAccumulator[t.v[0].pos] = DirectX::XMVectorZero();
		if ( normalAccumulator.count(t.v[1].pos)==0 )
			normalAccumulator[t.v[1].pos] = DirectX::XMVectorZero();
		if ( normalAccumulator.count(t.v[2].pos)==0 )
			normalAccumulator[t.v[2].pos] = DirectX::XMVectorZero();

		normalAccumulator[t.v[0].pos] = DirectX::XMVectorAdd(normalAccumulator[t.v[0].pos], faceNormal);
		normalAccumulator[t.v[1].pos] = DirectX::XMVectorAdd(normalAccumulator[t.v[1].pos], faceNormal);
		normalAccumulator[t.v[2].pos] = DirectX::XMVectorAdd(normalAccumulator[t.v[2].pos], faceNormal);
	}

	for ( TRIANGLE& t : triangles )
	{
		for ( int i=0 ; i<3 ; i++ )
		{
			DirectX::XMVECTOR sumNormal = normalAccumulator[t.v[i].pos];
			sumNormal = DirectX::XMVector3Normalize(sumNormal);
			DirectX::XMStoreFloat3(&t.v[i].normal, sumNormal);
		}
	}
}

void MESH::CalculateBox()
{
	aabb.min.x = FLT_MAX;
	aabb.min.y = FLT_MAX;
	aabb.min.z = FLT_MAX;
	aabb.max.x = -FLT_MAX;
	aabb.max.y = -FLT_MAX;
	aabb.max.z = -FLT_MAX;

	for ( TRIANGLE& t : triangles )
	{
		for ( int i=0 ; i<3 ; i++ )
		{
			if ( t.v[i].pos.x<aabb.min.x )
				aabb.min.x = t.v[i].pos.x;
			if ( t.v[i].pos.y<aabb.min.y )
				aabb.min.y = t.v[i].pos.y;
			if ( t.v[i].pos.z<aabb.min.z )
				aabb.min.z = t.v[i].pos.z;
				
			if ( t.v[i].pos.x>aabb.max.x )
				aabb.max.x = t.v[i].pos.x;
			if ( t.v[i].pos.y>aabb.max.y )
				aabb.max.y = t.v[i].pos.y;
			if ( t.v[i].pos.z>aabb.max.z )
				aabb.max.z = t.v[i].pos.z;
		}
	}	
}

#pragma once

struct TRANSFORM
{
	// Position
	XMFLOAT3 pos;

	// Scaling
	XMFLOAT3 sca;

	// Rotation
	XMFLOAT3 dir;
	XMFLOAT3 right;
	XMFLOAT3 up;
	XMFLOAT4 quat;
	XMFLOAT4X4 rot;

	// World
	XMFLOAT4X4 world;
	
	TRANSFORM();
	void Identity();
	void Update();
	void SetScaling(float scale);
	void SetPosition(float x, float y, float z);
	void Move(float dist);
	void ResetRotation();
	void SetRotation(TRANSFORM& transform);
	void SetYPR(float yaw, float pitch = 0.0f, float roll = 0.0f);
	void AddYPR(float yaw, float pitch = 0.0f, float roll = 0.0f);
	void LookAt(float x, float y, float z);
	void LookTo(float ndx, float ndy, float ndz);
	void LookTo(XMFLOAT3& ndir);
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

struct ENTITY
{
	int index;
	int sortedIndex;
	bool dead;
	MESH* pMesh;
	TRANSFORM transform;
	XMFLOAT3 view;
	MATERIAL* pMaterial;
	float lifetime;
	ui32 tile;
	float radius;
	AABB aabb;
	OBB obb;
	RECTANGLE box;
	bool clipped;
	byte depth;

	ENTITY();
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

struct FRUSTUM
{
	XMFLOAT4 planes[6]; // left, right, bottom, top, near, far

	FRUSTUM();
	void FromViewProj(const XMFLOAT4X4& viewProj);
	bool Intersect(const XMFLOAT3& center, float radius);
	XMVECTOR XM_CALLCONV NormalizePlane(FXMVECTOR p);
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

struct CAMERA
{
	float fov;
	float near;
	float far;
	XMFLOAT4X4 matView;
	XMFLOAT4X4 matProj;
	XMFLOAT4X4 matViewProj;
	TRANSFORM transform;
	FRUSTUM frustum;

	CAMERA();
	void UpdateProjection(float aspectRatio);
	void Update();
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

template<typename T>
struct MANAGER
{
	std::vector<T*> list;
	std::vector<T*> sortedList;
	int count;
	std::vector<T*> bornList;
	int bornCount;
	std::vector<T*> deadList;
	int deadCount;

	MANAGER()
	{
		Clear();
	}
	void Clear()
	{
		list.clear();
		sortedList.clear();
		count = 0;
		bornList.clear();
		bornCount = 0;
		deadList.clear();
		deadCount = 0;
	}
	T* operator[](int index) { return list[index]; }
	T* Create()
	{
		T* p = new T;
		if ( bornCount<bornList.size() )
			bornList[bornCount] = p;
		else
			bornList.push_back(p);
		bornCount++;
		return p;
	}
	void Add(T* p)
	{
		if ( bornCount<bornList.size() )
			bornList[bornCount] = p;
		else
			bornList.push_back(p);
		bornCount++;
	}
	void Release(T* p)
	{
		if ( p==nullptr || p->dead )
			return;
		p->dead = true;
		if ( deadCount<deadList.size() )
			deadList[deadCount] = p;
		else
			deadList.push_back(p);
		deadCount++;
	}
	void Purge()
	{
		// Born
		for ( int i=0 ; i<bornCount ; i++ )
		{
			T* p = bornList[i];
			if ( p->dead )
				continue;
			p->index = count;
			p->sortedIndex = p->index;
			if ( p->index<list.size() )
				list[p->index] = p;
			else
				list.push_back(p);
			if ( p->sortedIndex<sortedList.size() )
				sortedList[p->sortedIndex] = p;
			else
				sortedList.push_back(p);
			count++;
		}
		bornCount = 0;

		// Dead
		for ( int i=0 ; i<deadCount ; i++ )
		{
			T* p = deadList[i];
			if ( p->index==-1 )
			{
				delete deadList[i];
				deadList[i] = nullptr;
				continue;
			}
			if ( p->index<count-1 )
			{
				list[p->index] = list[count-1];
				list[p->index]->index = p->index;
			}
			if ( p->sortedIndex<count-1 )
			{
				sortedList[p->sortedIndex] = sortedList[count-1];
				sortedList[p->sortedIndex]->sortedIndex = p->sortedIndex;
			}
			delete deadList[i];
			deadList[i] = nullptr;
			count--;
		}
		deadCount = 0;
	}
};

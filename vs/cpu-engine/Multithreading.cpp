#include "stdafx.h"

void cpu_tile::Reset()
{
	// Entity
	statsDrawnTriangleCount = 0;

	// Particle
	for ( size_t i=0 ; i<particleLocalCounts.size() ; i++ )
		particleLocalCounts[i] = 0;
	particleCount = 0;
	particleOffset = 0;
	particleOffsetTemp = 0;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

cpu_thread_job::~cpu_thread_job()
{
	CloseHandle(m_hEventStart);
	CloseHandle(m_hEventEnd);
}

void cpu_thread_job::Create(int count)
{
	m_count = count;
	m_hEventStart = CreateEvent(nullptr, FALSE, FALSE, nullptr);
	m_hEventEnd = CreateEvent(nullptr, FALSE, FALSE, nullptr);
	m_pJob = nullptr;
	m_isWorking = false;
}

void cpu_thread_job::Stop()
{
	QuitAsap();
	PostStartEvent(nullptr);
	Wait();
}

void cpu_thread_job::PostStartEvent(cpu_job* pJob)
{
	m_pJob = pJob; SetEvent(m_hEventStart);
}

void cpu_thread_job::PostEndEvent()
{
	SetEvent(m_hEventEnd);
}

void cpu_thread_job::WaitStartEvent()
{
	WaitForSingleObject(m_hEventStart, INFINITE);
}

void cpu_thread_job::WaitEndEvent()
{
	WaitForSingleObject(m_hEventEnd, INFINITE);
}

void cpu_thread_job::OnCallback()
{
	while ( true )
	{
		WaitStartEvent();

		if ( m_quitAsap )
			break;

		m_isWorking = true;
		while ( true )
		{
			int index = CPU.NextTile();
			if ( index>=m_count )
				break;

			if ( m_pJob )
				m_pJob->OnJob(index);
		}
		m_isWorking = false;

		PostEndEvent();
	}
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void cpu_job::Create(cpu_thread_job* pThread)
{
	m_pThread = pThread;
}

void cpu_job_entity::OnJob(int iTile)
{
	CPU.Render_TileEntities(iTile);
}

void cpu_job_particle_physics::OnJob(int iTile)
{
	int min, max;
	CPU.GetParticleRange(min, max, iTile);
	CPU.GetParticleData()->UpdatePhysics(min, max);
}

void cpu_job_particle_space::OnJob(int iTile)
{
	CPU.Render_AssignParticleTile(iTile);
}

void cpu_job_particle_render::OnJob(int iTile)
{
	CPU.Render_TileParticles(iTile);
}
